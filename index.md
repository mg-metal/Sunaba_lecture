# Sunaba講座
## 本講座の対象
- C言語習得を迫られているのに、プログラミング学習経験が無い、もしくは無いに等しい人
- 過去のプログラミング学習で、黒い画面に文字が表示されるだけの環境にやる気を無くした人

## 対象外の人
- 何かしらのプログラミング言語を学習し、黒い画面に文字だけの世界に楽しさを見い出せた人
- 時間がたっぷりあって、お手本プログラムを写しながら徐々に慣れていく方法を採れる人
- [書籍『 プログラムはこうして作られる - プログラマの頭の中をのぞいてみよう 』](https://www.amazon.co.jp/dp/479803925X) を読み切ることができそうな人（まずはそちらにチャレンジ！）

## 何のためにプログラミングを勉強するのか？
- できれば `何のためにプログラムを学ぶか` を意識して、ここでの学習が役立ちそうかどうかを判断してもらいたい
- その目的意識が `とりあえずやってみたい！` であっても、それはそれで立派な目的なので歓迎します
- 本内容はC言語を学ぶ前提で話を進めるが、汎用性のある内容も含んでいる。C言語を学ぶつもりがなくても、Sunabaが合う人は本テキストを利用してもいいんじゃないかと思う

## Sunabaってなに？
- 教育用のプログラミング言語である  
- とりあえずお手本（テトリス）を見よう
- 開発環境の説明はビデオ通話の画面共有で実施
    - 独学で頑張る人は [Sunaba公式ページ](https://hirasho.github.io/Sunaba/) を参照

## Sunabaの特徴
- 覚えなきゃならない約束事が少ない
- 大抵の機能は自分で作らないといけない
    - 例えば、`線を引く` 機能すら用意されていない
- ここで作ったプログラムは、他のプログラミング言語へ流用できない
- 頑張った成果は、みんなの身体の中に残る！

## はじめからC言語でいいじゃん
- 大丈夫な人はSunabaをやる必要ない
- （研修では）大丈夫かどうかやってもらわないとわからないので全員強制参加です
- Sunabaは日本語でプログラミングできるけど、この後にC言語学習が待ち構えているので、初めから英語で頑張ろう

---
---
## **課題00** はじめの一歩
- SunabaにおけるHello World的なプログラム
    <details><summary>うんちく</summary>

        プログラミング言語を学習する時、はじめの一歩として、画面に『Hello World!』の一行を表示させるプログラムを書く習わしがある（情報の出所は書籍『プログラミング言語C』だと思う）
    </details>

- OneDriveに『sunaba_氏名』というフォルダを各自で作成
    - 課題ごとに作成したプログラムファイルを格納するためのフォルダ
    - プログラミング作業はデスクトップ等のローカルディスク上で実施する
    - 完成したらOneDriveにアップロードする
- まずはテキストファイル『Kadai00.txt』を作ろう
- １行目に  `memory[65050] -> 999999` と書いて保存
- はじめての実行
    1. Sunaba.exeを実行
    1. Sunabaウィンドウに Kadai00.txt をドラッグ＆ドロップ
    1. おめでとう！

---
### `memory[65050] -> 999999` の意味
- memoryはメモリ。記憶領域のメモリのこと
- `memory[...]` の `...` は、メモリの番号
- Sunabaのメモリはダイヤル式
    - 空っぽの状態にはならない、と言いたいだけです
    - 口答で解説する時にメモリの例えがダイヤルじゃなくて `箱` になることがあります。その際は脳内変換してください。。。
- 65050番のメモリのダイヤルを 999999 に合わせるよ という意味

---
### メモリなのに画面表示？
- メモリには種類がある
- 0～39999番は一般的な記憶領域。数値を記憶するだけ。***<font color = 'orange'>読み書き可</font>***
- 60000～69999番は、ダイヤルから信号線が出ていて、ディスプレイの画素に繋がっているイメージ。***<font color = 'orange'>書き込みのみ可</font>***、 ***<font color = 'red'>読み込み不可！</font>***
    - メモリ番号と画素の位置関係は早見表を参照
- メモリは一度書き込んだ数値を保持する
    - もちろん、異なる値で上書きするまでの話
- 画面メモリであれば、格納した数値の色を『ずっと』表示することになる
    - 色を変えたい時は違う数値を上書きすれば良い
    - 画面更新の話は後ほど

---
---
## **課題01** 画面に点をたくさん表示
- タイトル通り、`画面に点をたくさん表示` させてみよう。どこにいくつ点を描くかはお任せする
- ファイルは新規作成
- プログラミング講座ではバグの発生状況を確認したい場面が多い
    - 研修中は、こまめにファイルを新規作成してほしい
    - 開発現場ではバージョン管理ソフトを使う。これならファイル名を変えて保存をしなくて済む。興味がある人は調べてみよう
- **<font color = 'green'>HINT</font>**
    - <font color = 'Silver'>プログラムは上から順番に実行されていく</font>
- 以下、C言語/マイコン講座で学習予定の内容を先どりで実施する  

---
### メモリマップド I / O
- Sunabaにおけるメモリと画面の仕組みは、`メモリマップド I / O` と呼ばれる形式をとっている
- メモリマップド I / O とはコンピュータ内部の形式の一種
    - I / Oとは input/output 、つまり入出力のこと
- コンピュータにおける入出力は、`どこから見た入出力か`によって対象が変わる
    - パソコンなら、
        - 出力：ディスプレイ, スピーカー, , ,
        - 入力：キーボード, マウス, , ,
    - マイコンだと、
        - 出力：LED, 液晶表示器, , ,
        - 入力：スイッチ, 可変抵抗器, , , 等々
- メモリマップド I / Oは、コンピュータ（の頭脳部分）と入出力機器とのやりとりを、メモリの読み書きと同じ方法で実行できる仕組み  

---
### メモリってそんなに大事？
- メモリを理解していないとプログラミングできないの？
    - No！！ ......いや、Yes の場合もある
- PCやWEB上で動くアプリケーションを作るなら、メモリを意識することは少ないと思う
    - webアプリ開発の場合は、データ通信量（トラフィック）の対処の方が重要そうです
    - 日記アプリや店舗管理システムを作る際、細かなメモリ管理はきっといらないでしょう
        - 今時のプログラミング言語には、メモリ領域の解放をお任せできるガベージコレクションという機能がある
- ゲーム開発は、メモリ管理必須でしょう（ジャンルによるかも）
- なんにせよ、この研修では後日、C言語を使ってマイコンのメモリやI/Oを直接操作することになる
- Sunabaでメモリ操作に慣れておこう

---
---
## **課題02** 線を描く
- `画面左上端から右上端に直線を引く`
- **<font color = 'green'>HINT</font>**
    - <font color = 'Silver'>線は点の集まり</font>
- まずは解説を読まずにチャレンジ
    - プログラミング経験者は早見表を見て良い
    - 未経験者は`100行プログラム`を書いてみよう
        - コピペを活用すること!
- これ以降は、一つに課題につき複数のプログラムを作る可能性が高い。`kadai02_01.txt`という

### 課題02の解説
- 100行プログラムの解説は不要でしょう。100行書かずに済むプログラムについて解説する
- プログラミング未経験者にとっては初めての要素が多い。がんばろう
1. メモリ番号の変化を確認し、法則性を見出す
    - 画面メモリ番号が `1つずつ` 増えてる
    - 点を描く回数と長さが一致している（単位：ドット）
1. 新しいテクニックやルールの紹介
    - プログラムを短くするには、一つの式を繰り返し実行する仕組みが必要
    - ただし、同じ結果になる式を何回繰り返しても意味がない
        - 60000番メモリに100回同じ色を書き込んでも意味がないでしょう？
    - 実行するたびに変化させたい箇所を変化させる仕組みが必要
    - 点を描く回数を数えるメモリを用意する（カウンタと呼ぶ）
        - 何番でも構わないが、ここでは `memory[0]` をカウンタとして使うことにする
    - `memory[....] -> ***** ` の右辺は、１つの値だけでなく、式で表現できる
    - `memory[....]` のカッコ内も式を使える
    - 式の数値を変えながら、繰り返し実行できれば、100行書かずに済みそうでしょう？
    - 式を繰り返し実行させる仕組みは `while（呼び方：ワイル）` を使う
    - 式のルールと、whileのルールを順番に解説しよう 

---
### 式のルール
- 式の種類：代入式と判定式
    - 代入式：課題00と課題01で書いた式。`->` の左側のメモリを、`->` の右側の値に設定する式
    - 式：計算結果が式の場所に返ってくる形式を、単なる `式` と呼ぶ
    - 判定式：式の呼び名を変えたもの。制御構文（while, if）の動作を決める式を `判定式` と呼ぶ（後述）
- 式の構成要素
    - 数値：整数のみ。小数は不可。使用可能範囲は －20億 から ＋20億（使用場面により範囲は変動する）
    - メモリ：メモリ0~39999番に格納できる数値も －20億 から ＋20億。他の番地は役割毎に扱う数の範囲は異なる（早見表参照）
    - メモリの使い方には禁止事項がある
        - 書き込み不可メモリは、代入式の左辺に置けない
        - 読み込み不可メモリは、代入式の右辺に置けないし、判定式にも使えない
- 構成要素をつなげる演算子
    - 代入演算子：->
    - 算術演算子：+, -, *, /
    - 比較演算子：=, >, <, !=, >= ,<=

---
### whileのルール
- 繰り返しは `while  判定式` を使う
- 判定式には代入記号 `-> が無い`。単なる **式**
    - 数値やメモリを算術/比較演算子でつなげた式（数値・メモリが単体で存在するだけでも可）
        - 比較演算子は、関係演算子と呼ばれることもある
    - 例：5, -8, memory[100], 1+1, memory[0]-1, 1<3, 3<2, memory[4]>=10, d=12, , , , ,
    - 式の計算結果が、その場所に返ってくる（分かりにくい！）
    - これを理解するにはプログラムを実行する『Sunaba君』になりきる必要がある
    - Sunaba君はプログラムを上から一行ずつ読解＆計算している
    - 例えば、`while (1+1)` と書かれた所に差し掛かったとする
    - そうしたら `while (2)` に変換してから次の動きを決めるのである

- 判定式の演算結果が **<font color = 'orange'>真</font>** な限り、「while文の中のプログラム」を繰り返し実行する
- 判定式の演算結果が **<font color = 'skyblue'>偽</font>** なら、「while文の中のプログラム」を飛ばして、下に続くプログラムに移動する
    - **<font color = 'orange'>真</font>** **<font color = 'skyblue'>偽</font>** を端的にいえば
        - 真：演算結果が０以外
            （比較演算子の式の場合、式が正しければ1が返ってくる）
        - 偽：演算結果が０（比較演算子の式の場合、式が間違っていれば 0 が返ってくる）
    - 「while文の中のプログラム」とは？
        - インデント（TABキー1回 or Spaceキーn回分）によって、`while ` の下かつ右側に奥まったプログラムが繰り返しの対象となる
        - インデントは TAB / Space どちらでも構わないが、読みやすさは意識するように。
            - VS Code でプログラムを書いている場合はTABがいい
            - テキストエディタによっては、デフォルト設定のTAB幅が大きい場合がある
            - 半角Spaceの場合は3つでお願いしたい（1つだと読みにくい）
            - 統一していないとエラーになる（試してみよう）

1. 最終的にどんな形になるのか

    <details><summary>kadai02 疑似コード</summary>
    <pre><code>
    memory[0] -> 0   # カウンタ
    while memory[0] < ＿＿＿＿
        点描画
        カウントアップ
    </code></pre>
    </details>

1. 詳細解説
    - アップ式カウンタの判定式は『カウンタ < 繰り返したい回数 』という形がよく採られる
        - 繰り返し回数をそのまま書けるのが利点
        - カウンタがゼロスタート、比較演算子に `<`（未満）を使っている点に注意
            - <font color = 'Silver'>【C言語 予習】カウンタがゼロスタートの理由は、コンピュータの世界は0から数えることが多いため。Sunabaで言えばメモリは０番地から始まっている。とはいえ身近にあるExcelは「1行目」が基点になるシステムだったりする。。。柔軟に受け止めてほしい</font>
        - 慣れないうちは紙に書いてプログラムの動きを追う練習がおすすめ
            - 3～5回程度の小さな繰り返しプログラムを用意
            - Sunaba君になったつもりで、カウンタの変化、画面メモリ操作状況、繰り返し状況を確認しながら読解する
    - `#` 記号より右側は「コメント」として、Sunaba君はプログラム実行時に無視してくれる。メモリや式、小さなプログラムの役割を、言葉で明示する時に重宝する
    - `while (判定式)` のように（）で括ってもよい。C言語は（）無しだと文法エラーになる。

---
---
## **課題03** 四角を描く
- `画面左上端に１０×１０ドットの正方形を描く（塗潰し）`
- 今回は１００行プログラムはやめようか 
    - 100行書いてもいいけどコピペを活用すること
- チャレンジャーなら、まずは解説を無視してコードを書いてみましょう
    - **<font color = 'pink'>（以下、研修用）【横道に逸れるけど大事なこと】</font>**
    - `独学する際の姿勢と、職場で求められる態度はちがう（時がある）` という話
    - 注意されて『前と言ってることが違う』と感じたら、それは重視すべきことが場面によって異なるから、というケースはありそう
    - 今回で言えば、Sunaba講座はSunabaでプログラミング技能を向上させることが目的なので、現場に配属されてから心がけるべき態度は考慮していない（解説を無視して挑戦しろって言ってる）
    - とはいえ、職場に配属されたら謙虚さが必要である。とても大事。
    - 周囲のアドバイスを聞かない人・聞けない人は残念な結果になることが多い。本当に大げさじゃないんです。。。
    - 『自分、そういうところあるかも』という人は気をつけよう（私も気をつけます）
    - 何事もバランスが大切です

### 課題03の解説（Ver.1）
1. まずは課題02 のプログラムを使って、カンタンに実現できないか考えてみよう
1. 画面のどの位置からスタートして横線を描いたか？に注目する
1. 課題02は60000番から100ドット長の横線を引いた
1. 四角を横線の集合だと考える
1. １０ドット長の横線を１０本、縦に並べるプログラムを書いてみよう
1. 最終形
    - コピペを活用しよう
    <details><summary>kadai03_1 疑似コード</summary>
    <pre><code>
    60000番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    6****番スタートかつ10ドット長の横線プログラム
    </code></pre>
    </details>

### 課題03の解説（Ver.2）
1. Ver.1の問題点
    - 四角の縦の長さに比例してプログラムが長くなる
1. 課題02で横線プログラムを繰り返しプログラムに変更したときのプロセスを再確認する
1. 今回の法則性を考える
    - どこが変化している？ ： 横線スタートの画面メモリ番号
    - 変化の規則性は？ ： ＊＊＊＊＊＊＊＊＊＊（各自考えてほしい！）
    - 式にするには？ ： 規則性を一つの式で表す（ヒントになっていないな。。）
1. 最終形
    - 文章だけで解説することが難しいので、疑似コードのコメントを参照
        - 過剰なコメントはあくまで解説用（普段はこんな書き方しなくていいです）
    <details><summary>kadai03_2 疑似コード</summary>
    <pre><code>
    memory[1] -> 0  # 縦長さカウンタ
    while memory[1] < ________
        # 横線プログラム 開始
        memory[0] -> 0   # 横線長さカウンタ
        while memory[0] < ＿＿＿＿
            点描画       # 横線長さカウンタと縦長さカウンタで構成した式
            横線長さカウンタのカウントアップ
        # 横線プログラム 終わり
        縦長さカウンタのカウントアップ
    </code></pre>
    </details>

---
---
## **課題04** 点を横方向に走らせる
- `画面左上から右に点を走らせる。距離は10ドット程度でOK`
- PC画面でアニメーションさせるとはどういう事だろう？
- パラパラ漫画を思い浮かべてほしい
- Sunabaでやっていることはパラパラ漫画に近い
- パラパラ漫画とSunabaが異なる点
    - リアルタイムでお絵描きしている
        - 1枚表示している間に、次に表示する1枚を急いで描く
        - 描き終えたら、新しい絵を画面に表示する
    - 絵を切り替えるタイミングは1/60秒毎
        - Sunabaは1/60秒毎に1枚表示しようと頑張る
        - 1枚描く時に考える（計算）時間が長いと、更新速度が遅れる
        - 逆に、早く描けてしまった場合は、1/60秒更新になるよう待機する
- 絵を切り替える動作を『 画面更新 』と呼ぶ  

---
### 画面更新の詳細
- Sunabaは、画面メモリにアクセスする命令を実行すると、 `自動的`に60000～69999番の値すべてを実際の画面に反映する
- 例として、2×2ドットの四角を画面中心辺りに描くプログラムで説明しよう
    <pre><code>
    memory[64949]->990099
    memory[64950]->990099
    memory[65049]->990099
    memory[65050]->990099
    </code></pre>

    - 前提条件として、Sunabaは起動直後、全メモリの数値が0（画面メモリ的には黒）である
    - 1行目 `memory[64949]->990099` をSunaba君が読み取って実行
        - `64949番だけピンク、他の9999個の画面メモリは全て黒` の1枚絵（計10000メモリの情報）をPC画面表示部に送信
    - 2行目 `memory[64950]->990099` をSunaba君が読み取って実行
        - `64949,64950番がピンク、他の9998個の画面メモリは全て黒` の1枚絵（計10000メモリの情報）をPC画面表示部に送信
    - 3行目 `memory[65049]->990099` をSunaba君が読み取って実行
        - `64949,64950,65049番がピンク、他の9997個の画面メモリは全て黒` の1枚絵（計10000メモリの情報）をPC画面表示部に送信
    - 4行目 `memory[65050]->990099` をSunaba君が読み取って実行
        - `64949,64950,65049,65050番がピンク、他の9996個の画面メモリは全て黒` の1枚絵（計10000メモリの情報）をPC画面表示部に送信
    - プログラム終了（最後の絵が表示された状態で終了）
- 1ドット打つたびに画面が更新される様子は、今まで見てきたのでイメージできると思う
- これでは大きな絵を表示し終えるまでに長い時間が掛かる（1/60 * 10000 sec）
- 1枚絵を一気に表示する機能は用意されているが、それは次の課題で解説する
- Sunabaは、なんでこの仕組みをデフォルト設定にしているのか
    - プログラムが実行される様子を、画面の動きをみて実感できるようにするため
    - 横線を縦に並べることで四角を描くプログラムを再確認してほしい。横線が上から徐々に描かれる様子がアニメっぽく表示されているはずである
    - Sunabaは初心者のため開発言語なので、デフォルトがこの設定なのである
- 画面更新の中でも、今回のデフォルトの動作を『自動更新』と呼ぶ
    - これに対なす機能として、プログラマが画面更新タイミングを決める『手動更新』というものが用意されている。これは後々の課題で解説する  

---
### 課題04の解説
- 画面更新の話が長くて、課題の内容が頭から抜けたと思うので再掲しよう
    - `課題04：画面左上から右に点を走らせる。距離は10ドット程度でOK`
- 自動更新の仕組みを意識して、点が動くように見えるプログラムを考えてみよう
    - whileを使わず、コピペコードでOK
    - 点滅するが、仕組み上どうにもならないので気にしないこと
- 疑似コード
    <details><summary>kadai04 疑似コード</summary>
    <pre><code>
    60000を白
    60000を黒
    60001を白
    60001を黒
    ・・・・
    ・・・
    ・・
    </code></pre>
    </details>

---
---
## **課題05** 点を走らせるスピードを変更
- `課題04のプログラムの改造。移動速度を２倍にしよう。距離は任意とする`
- 画面更新スピードはSunaba君に一任しているので変更できない。
- どうする？ これはノーヒントで頑張ってみよう

---
---
## **課題06** 点を斜めに走らせる
- `画面左上端から右下へ移動。右下側 45°の方向に進める ( 右 と 下 の移動量がそれぞれ1ドット ）。距離は任意とする`
- どのような方法でも構わない。指定通りの動作が実現できればOKとする
- ノーヒント

---
---
## **課題07** 斜め移動の角度を変える
- `画面左上端から右下方向へ移動。右移動量：1 と 下移動量：3 とする`
- 課題05と課題06は、どのようなコードを書いてきただろうか？
    - `パターンA`：移動経路を画面メモリMAPを確認しながら、`memory[6****] -> 999999` コピペ ＆ 画面番号を直打ち
    - `パターンB`：独自の規則性を見出して`while`で回した
    - 以下、`パターンB`の各々独自方法に対するコメントは不可能なので、`パターンA`で書いた人に向けた解説をする
- 画面メモリMAPを確認しながらのプログラミングも面倒になってきたと思う
- 座標を指示することで点を描くことができれば、面倒さが無くなるはずである  

---
### 画面メモリの座標系
1. 画面メモリ番号の法則性
    - 左上端60000からジグザグしながら右下端69999にたどり着くことは理解できていると思う
    - 横方向について1増えれば右に1つ移動することも分かると思う
    - 縦方向はどうだろう？各自確認しよう
        <details><summary>縦方向の法則</summary>
        縦方向は100増えると下に1つ移動する
        </details>
1. 画面メモリ番号の法則を利用した点描画プログラムを作りたい
    - 全ての絵は点で描く。点描画を制すれば万事うまくいくはず！
1. 式にやってもらいたいことは？ 式の入出力に注目する。
    - 式に渡すもの（入力）：位置情報
    - 式が返してくれるもの（出力）：該当する画面メモリの番号
1. 式に渡す位置情報は以下のメモリに格納しよう
    - 横方向の位置：`memory[0]`
    - 下方向の位置：`momory[1]`
1. 式を作るにあたっての条件
    - 60000番が原点
    - 1増えると右に1移動
    - 100増えると下に1移動
    - 位置情報メモリの設定範囲は0～99とする
        - 範囲を決めるのも守るのもプログラマーの仕事である
        - Sunaba君は勝手に判断してくれない。つまり「 `memory[0]` と `memory[1]` は 0 ~ 99 の範囲外に出たらエラーを出す」なんて便利な機能はない<font color="Silver">（自分でそういうプログラムを書けばいい。それは後々考えていこう）</font>
1. まずは、問題ありVer.を示そう

    <details><summary>kadai07 問題ありVer.</summary>
    <pre><code>
    memory[0] -> 30     # 右方向の位置
    memory[1] -> 40     # 下方向の位置
    memory[60000 + memory[1] * 100 + memory[0]] -> 990099
    </code></pre>
    </details>

    - まずは実行してみてほしい
    - 他の言語だと問題ないがSunabaだとNG
    - Sunabaには演算子の優先順位が設定されていない。算数でいうと+-よりも×÷を優先する、というあのルールだ。
    - `Sunabaの式の計算は左から右へ処理`される。つまり3行目は `60000 + memory[1]`が最初に計算されてしまう。
    - 優先順位をコントロールしたい場合は（）をつける。
    - `60000 + (memory[1] * 100) + memory[0]` とすればOK。修正して実行してみよう
1. これまで、右方向・下方向 という言い回しをしてきたが、コンピュータの世界では、`画面の左上端を原点として右方向をX軸方向、下方向をY軸方向` とする座標系はよく採用されている。本テキストもこれ以降、X,Yを使って説明する  

---
### 課題07の解説(Ver.1)
- 課題を再掲する
    - （再掲にあたって、`辺り`という曖昧表現の付与と、右/下 を x/y表記に変更した）
    - `課題07：画面左上端"辺り"から右下方向へ移動。x移動量：1 と y移動量：3 とする`
- 位置xと位置yの初期値を0として、更新される度にxは1増加、yは3増加
- 最終形は`while`を使った疑似コードを示す
    - 進む距離は画面端までとする
    - y方向の画面端に先に到達するので、繰り返し終了条件はyの値で判定する
    - 初期位置x:0, y:0 地点での点の表示は無くてOK。『画面左上端`辺り`から』なので。

    <details><summary>kadai07_1 疑似コード</summary>
    <pre><code>
    memory[0] -> 0     # 点のx座標位置
    memory[1] -> 0     # 点のy座標位置
    while memory[1] < _____
        前回表示の点を黒で塗りつぶす
        点のx座標位置を+1
        点のy座標位置を+3
        memory[60000 + (memory[1] * 100) + memory[0]] -> 990099     # 今回表示の描画
    </code></pre>
    </details>

### 課題07の解説(Ver.2)
- Ver.1の問題点
    - x,yの移動量について、点描画の式に値をそのまま書いた
        - プログラムの計算部で直接値を記している部分を『リテラル』と呼ぶ
        - 考えがあって使う分には否定しないが、明らかに問題ない場合を除いて、リテラルは無くした方がいい
- 移動量もメモリで管理してみよう
- 最終形

    <details><summary>kadai07_2 疑似コード</summary>
    <pre><code>
    memory[0] -> 0     # 点のx座標位置
    memory[1] -> 0     # 点のy座標位置
    memory[2] -> 0     # 点のx方向移動量
    memory[3] -> 0     # 点のy方向移動量

    while memory[1] < _____
        前回表示の点を黒で塗りつぶす
        点のx座標位置を+memory[2]
        点のy座標位置を+memory[3]
        memory[60000 + (memory[1] * 100) + memory[0]] -> 990099
    </code></pre>
    </details>

- そろそろ `memory[....]` だらけのプログラムに嫌気がさしてきたのではないだろうか
    - 以降、嫌気がさした前提で話が進む。まだまだ `memory[....]` の世界にどっぷり浸かりたい人は、以下のテクニックを使ってほしい
    -  `memory[....]` を `m[....]` に短縮する方法
        - <font color = "Silver">（以下の解説、現時点で分からなくてもいい。『コードの冒頭で`const m -> 0` を書けば `m[....]` でメモリ操作できる』それだけ理解してくれればOK）</font>
        -  定数によるSunabaメモリ操作の短縮文法を適用する（『Sunaba上級ガイド.pdf』の3.4.2, 3.4.3 を参照）
        - 【注意事項】 変数名に `m` は使えなくなる（ `m` を含む複数文字で構成した単語は大丈夫。 `m` １文字の変数名が使えなくなるだけ）
            <pre><code>
            const m -> 0
            m[0] -> 50   # x座標
            m[1] -> 30   # y座標
            m[2] -> 994599   # 色

            m[ 60000 + (m[1] * 100) + m[0] ] -> m[2]
            </code></pre>

- Sunabaは読み書き可能なメモリに名前をつけて、その名前を使ってプログラムを組むことが可能である
    - この機能を`名前付きメモリ`というが、本講座ではC言語と同じ`変数`という呼び名を用いる  

---
### 変数（名前付きメモリ）
- プログラムを読み書きしやくする仕組みである
- 管理したい情報と変数名を決める
    - 点のx座標位置： x 
    - 点のy座標位置： y 
    - 点のx方向移動量： dx
    - 点のy方向移動量： dy
- プログラムで使うには、以下のように名前と初期値をセットで記述するだけ
    <pre><code>
    x -> 0
    y -> 0
    dx -> 1
    dy -> 3
    </code></pre>

- 変数はメモリ番号 40000 ～ 49999番 の中で、Sunaba君が自動で割り振る
    - `memory[0] -> memory[40000]` のように直接アクセスすることはできない

- 最終形の動きは変えずに、変数を使って書き直そう
    - 点の色も変数にしよう
    <details><summary>kadai07_3 疑似コード</summary>
    <pre><code>
    # 点
    x -> 0     # x座標
    y -> 0     # y座標
    dx -> 1     # x移動量
    dy -> 3     # y移動量
    color -> 990099     # 色

    while y < _____
        前回表示の点を黒で塗りつぶす
        xを+dx
        yを+dy
        memory[60000 + (y * 100) + x] -> color
    </code></pre>
    </details>

---
### 【上級者向けの話】 斜め移動のスピード （全体講義としては扱わない予定）
- `速い移動`はできても、『 `ゆっくり`斜めに移動させる 』は難しい、と感じてもらえるだろうか
- 崩せない条件
    - 画面更新頻度は一定（Sunaba君は勝手に1/60 secごとに画面更新しようと頑張る）
    - 画面表示における長さの最小単位は 1 ドット
    - 数値は整数のみ、小数不可
- 斜めの距離を計算するには小数が必要なのに、Sunabaのコードで小数を書くとエラーになる
    <details><summary>ヒント</summary>
    小数点を含む計算は、大きな値に変換した数値で計算し、100×100ドットの世界の大きさに戻す
    </details>
- 当然だが画素にも小数はありえないので、「1.5ドット進んだ状態」を画面に表示することはできない
    <details><summary>ヒント</summary>
    変換前の大きな値を100×100ドットの世界の世界に戻す時、小数点以下を切り捨てる。これがいい感じに作用する
    </details>

---
---
## **課題08** 四角を一瞬で画面描画させる
- `１５×２０の長方形を描く。ただし画面描画は一瞬で。`
- 一瞬で画面表示する方法は新機能の紹介待ち
- まずは課題03の四角を描くプログラムをコピーして、大きさを15×20に調整
    <details><summary>kadai08 疑似コード</summary>
    <pre><code>
    memory[1] -> 0  # 縦長さカウンタ
    while memory[1] < ________
        # 横線プログラム 開始
        memory[0] -> 0   # 横線長さカウンタ
        while memory[0] < ＿＿＿＿
            点描画       # 横線長さカウンタと縦長さカウンタで構成した式
            横線長さカウンタのカウントアップ
        # 横線プログラム 終わり
        縦長さカウンタのカウントアップ
    </code></pre>
    </details>
- これから画面更新における新機能『手動更新』の使い方を学び、上のコードを改造する  

---
### 手動更新（画面更新の方法を変える）
- 今までの画面描画は**自動更新**だった。60000番台にアクセスすると、その都度60000～69999番の情報を画面表示器に送信していた。だからジワジワと四角が描かれる様子を見て取れたのである。
- これからはデフォルト設定されている**自動更新**をやめて、**手動更新**を使う。Sunaba初級の卒業である
- **手動更新**は、描画したい絵の情報を全て画面メモリに入力してから、画面更新させる方法である
- モードを**手動更新**に切り替えるには、プログラムの序盤で、以下のコードを1度だけ実行する
    <pre><code>
    memory[55001] -> 1   # 手動更新モードに切り替え
    </code></pre>

- この1行を書くことで、画面メモリに値を書き込むだけでは画面更新が掛からなくなる（自動更新がOFFになったとも言える）
- 画面更新させたい場所に `memory[55000] -> 1` を書く
    - `memory[55000]` に `1` を書き込む行為が画面更新指示になる
        - 『memoryは書き込んだら値を保持するじゃないか？』という疑問は的を射ている
        - とはいえ、`memory[55000]` の中身が何であろうと、 `1` で上書きしようとする行為が`画面更新スイッチON`を意味するのである
        - これは言語仕様上のルールなので、柔軟に受け止めてほしい
    - 今回の課題08で言えば、全ての四角を画面メモリ書き込んだ後、つまり一番最後で実行すればいい
    - 通常のSunaba作品は、ずっと実行し続けるプログラムを書くことになる。いわゆる無限ループである。この場合、どこで画面更新するかが大事になる。この話題は今後の課題で取り組む
- 最終形
    <details><summary>kadai08_1 疑似コード</summary>
    <pre><code>
    手動更新モードに切り替え
    memory[1] -> 0  # 縦長さカウンタ
    while memory[1] < ________
        # 横線プログラム 開始
        memory[0] -> 0   # 横線長さカウンタ
        while memory[0] < ＿＿＿＿
            点描画       # 横線長さカウンタと縦長さカウンタで構成した式
            横線長さカウンタのカウントアップ
        # 横線プログラム 終わり
        縦長さカウンタのカウントアップ
    画面更新スイッチON
    </code></pre>
    </details>


- <font color="Silver">【補足】実は、、</font>
    - <font color="Silver">課題08のような無限ループの無いプログラムでは、手動更新モードに設定している場合、画面更新指示がなくても表示出来てしまう。</font>
    - <font color="Silver">これは手動更新モードの仕組みによるもの。プログラムが終了する時に、画面メモリの最終的な値を画面に出力するようになっている（Sunabaの仕様）</font>


---
---
## **課題09** たくさんの四角を描く
- `複数個の四角を描く。大きさ、個数、色、位置は任意である`
- 力技でまずはチェレンジしてほしい。ノーヒント

---
---
## **課題10** たくさんの点を描く（変数を使う）
- `複数個の四角を描く。個数、色、位置は任意である。ただし各パラメータは変数に格納して描画すること`  

---
### 課題10の解説（Ver.1）
- 座標x, y、色color を変数として用意。変数の新設を`変数宣言`と呼ぶので覚えておこう
- プログラム序盤に`変数宣言`を行ない、その下に、手動更新モード切替、プログラム本編の開始、という流れで書く
    - Sunabaの変数宣言はプログラム序盤に書かなくてもエラーにならないが、それでもできるだけ序盤に宣言しよう
    - <font color="Silver">後日学ぶC言語では { } で囲われたブロックにおいて、その { } 内の冒頭で変数宣言をしないとエラーになる</font>
        - <font color="Silver">C99以降の規格はエラーにならないが、開発環境によって古い規格が生きており、エラーになる可能性がある</font>
        - <font color="Silver">宣言場所を問わない環境であっても、ブロックの冒頭で変数宣言するのが苦にならないくらい1ブロックを小さくする。読みやすいコードになると思う（狙いが明確で、問題ないことも確認済なら新しいルールを使おう）</font>
    - Sunabaで学習しているうちに、「必要な変数は？」「変数の名前は？」「初期値は？」「必要なコメントは？」の最適な姿を目指し試行錯誤して、それらの情報を冒頭に書くことに慣れておこう
- プログラム本編のことは`メインプログラム`と呼ぶ
- 最終形
    <details><summary>kadai10_1 疑似コード</summary>
    <pre><code>
    # 変数宣言
    # 点
    x -> 0     # x座標
    y -> 0     # y座標
    color -> 990099     # 色

    手動更新モードに切り替え
    # メインプログラム
    # 点1
    x -> **
    y -> **
    color -> ******
    memory[60000 + (y * 100) + x] -> color
    # 点2
    x -> **
    y -> **
    color -> ******
    memory[60000 + (y * 100) + x] -> color
    # 点3
    x -> **
    y -> **
    color -> ******
    memory[60000 + (y * 100) + x] -> color
    画面更新スイッチON
    </code></pre>
    </details>

### 課題10の解説（Ver.2）
- Ver.1の問題点
    - 行数が増える。変数を使ってスマートになると思いきや、リテラル（値の直書き）を使った方がいいじゃないか、という状態だ
- ひとかたまりのプログラムに名前をつけて、その名前でプログラムを呼び出す方法がある。
- Sunabaでは**部分プログラム**と呼ぶ機能だが、この講座では後日学習するC言語に合わせて**関数**と呼ぶ  

---
### 関数（部分プログラム）  
#### 特徴１：実施内容が決まっている処理のパッケージ化
- 一番単純な使い方としては、ひとかたまりのプログラムに名前をつけて、メインプログラム側からそのプログラムを名前で呼ぶだけ、というもの
    <pre><code>
    # メイン
    部分プログラム名()

    # 関数定義
    def 部分プログラム名()
        処理内容
    </code></pre>

- Sunabaはプログラムを実行すると、ファイルの一番上から実行するが、関数定義だけ書いて実行されない
- 例：以下のコードだと、せっかく四角を描く関数を用意したのに呼び出されず、点だけが描かれる
    <pre><code>
    x -> 20
    y -> 30
    m[60000 + (y * 100) + x] -> 999900

    def shikaku()
        ************
        *******
        ****
    </code></pre>

- 関数定義を書く場所はプログラムの下でなくてもエラーにならないが、プログラムが小さい内はメインプログラムの下に書くと読みやすい
    - 大きくなったら、メインプログラムのファイルと関数のファイルを分けることもできる
- 実際に一つ動くプログラムを示そう。コピペでOK
    <pre><code>
    memory[55001] -> 1      # 手動更新モードに切り替え
    
    # メイン
    tenMittsu()             # 『点３つ描画』関数の呼び出し
    memory[55000] -> 1      # 手動更新スイッチON
        
    # 関数定義
    def tenMittsu()
        x -> 0              # x座標
        y -> 0              # y座標
        color -> 000000     # 色
        # 点1
        x -> 20
        y -> 30
        color -> 009900
        memory[60000 + (y * 100) + x] -> color
        # 点2
        x -> 40
        y -> 60
        color -> 990099
        memory[60000 + (y * 100) + x] -> color
        # 点3
        x -> 60
        y -> 90
        color -> 009999
        memory[60000 + (y * 100) + x] -> color
    </code></pre>

- 動くのは分かるが、なんのうまみもない。
- tenMittsu()関数は、何回呼び出そうが結果に違いは生まれない。3つの点を同じ場所、同じ色で上書きするだけである  

#### 特徴２：処理に必要な材料を、呼び出される時に入手できる（引数）
- 今回の課題で実現したいこと
    - 材料（座標と色）を与えるとその通りの点を描いてくれる
- 関数宣言の際、外からほしい材料を指定できる。これを`引数`と呼ぶ。
- 関数を呼び出す側は、指定された場所にデータを入れる
- プログラムは以下のようになる
    <pre><code>
    # メイン
    point(10, 30, 990099)
    point(20, 50, 009999)
    point(30, 70, 999900)

    # 関数定義
    def point(x, y, color)
        memory[60000 + (y * 100) + x] -> color
    </code></pre>

- 関数内に注目してほしいのだが、`def point(x, y, color)`の `x  y color` に入った値を、処理内容である `memory[60000 + (y * 100) + x] -> color` で活用している様子をイメージできるだろうか
- `引数`の個数に上限はない。しかし引数が多くなりすぎる場合はプログラムが分かりにくくなっている可能性がある。その時は構成の見直しをおすすめする
    - Sunabaの場合は整理する道具が少ないため、あえて引数を多くするケースはあるかもしれない。他言語に移行する時、その辺りは柔軟に対応してほしい  

#### 特徴３：関数の内側と、外側（メインプログラム側）では、お互い、相手の変数に直接アクセスすることはできない（有効範囲、スコープ）
- 今回の課題に限っては、引数をリテラルで渡すことで何も問題ないが、今後何か作品を作る時には、変数を使うことが多くなる
- 変数で値を渡すプログラムはこんな感じ
    ```
    x -> 35
    y -> 50
    color -> 990099
    # メイン
    point(x, y, color)

    # 関数定義
    def point(x, y, color)
        memory[60000 + (y * 100) + x] -> color
    ```

- これで正しく動く。だが、気になる点はないだろうか？
- 外の世界（メイン）の変数x, y, colorと、関数の引数x, y, color をみて、名前が同じである点に注目してほしい
- 結論から言うと、外の世界（メイン）の x, y, color と、関数の x, y, color は名前が同じであっても別物である
    - 関数の引数は、変数の一種である。`( )` 内で宣言して値を外からもらう、特別な変数である
        - <font color="Silver">引数の初期値設定が可能なプログラミング言語もある。デフォルト引数と呼ばれている（SunabaとC言語には無い。C++にはある）</font>  
    - あとで例を示すが、紛らわしさを無くすには関数側の名前を変えればいい
- メイン側で同じ名前の変数を作れないのは明らかである。しかし、メインと関数で同じ名前をつけて問題にならないのはどういうことなのか？
- これを理解するには、変数が持つ`有効範囲`という性質を知る必要がある。変数を読み書き（`アクセス`）できる範囲のことである
    - 有効範囲は`スコープ`と呼ばれている。覚えておこう
- 実際にコードを書いてエラーを確認し、スコープを実感してほしい
    - 以下のコードを実行しよう。どんなつもりで書いたコードかというと、関数の引数を無くして、関数内部から直接外の世界を見ることができないだろうか？という実験である
        ```
        x -> 35
        y -> 50
        color -> 990099
        # メイン
        point()

        # 関数定義
        def point()
            memory[60000 + (y * 100) + x] -> color
        ```

    - エラーが出ただろうか。関数の内側から外の変数を読めないことは、これで分かった
    - 逆に、関数の中で宣言した変数`abc`を、外から見られないか確認しよう。外で宣言した`color` に `abc` の値が入れられないか、という実験である
        ```
        # メイン
        test()
        color -> abc
        memory[60000 + (45 * 100) + 45] -> color

        # 関数定義
        def test()
            abc -> 85
        ```

    - こちらもエラーが出た。この挙動を解説するには新たな情報提供が必要だ。`関数内の変数の寿命`についてである。関数`test()`を実行した時に、変数`abc`（初期値85）が生まれているが、この `abc` は `test()` 実行終了と共に消滅している
    - 外から関数内の変数にアクセスできないというスコープの仕組み以前に、そもそも外の世界で `color -> abc` を実行する時には、abcは既に消滅しているのである
        - <font color="Silver">C言語の関数内変数も同じ挙動である。関数内ローカル変数、自動変数と呼ばれる。ただ、C言語の場合は消滅しない変数を作ることもできる。関数内の変数宣言の前にstaticをつけることで関数から抜けた後も変数と値を存続させることができる。こちらは静的変数と呼ばれている。とはいえ、この静的変数も存続はするが、外から読むことはできない。</font>

- 上の事例はスコープを説明するために、メイン側と関数側の変数名を同じにしたのである。みんながプログラムを書く時にこの紛らわしさをマネる必要はない。 関数側に `_（アンダーバー）` を入れるだけで紛らわしさを解消できる
    <details><summary>記述例</summary>
    <pre><code>
    x -> 35
    y -> 50
    color -> 990099

    # メイン
    point(x, y, color)

    # 関数定義
    def point(x_, y_, color_)
        memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </datails>

    -  <font color="Silver">実はテキスト作成当初、 `_x` のようにアンダーバーを前に付けていた。C言語には予約語に `_bool` といった形があり、 `変数名に 前付きアンダーバーの使用は避けよ` というルールがある。これを認識していなかったのである
    - 他にもこのような基本的な認識が漏れている可能性がある。疑いの目を持ちつつ、本テキストを使ってくれるとありがたい。そして、教えてもらえるとうれしいです</font>  

#### 特徴４：関数の内側からでもメモリ番号指示によるメモリへのアクセスは可能
- これまで以下のような記述をさりげなくしていたので意識していないだろうが、関数内からmemory[....] のアクセスは可能である
    <pre><code>
    def point(x_, y_, color_)
        memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>

- これが何を意味するか分かるだろうか
- 変数（名前付きメモリ）だと関数の内側と外側で共有することは出来なかった
- `memory[0] ～ memory[39999]` であれば、関数の内側と外側で同じデータを共有できることになる
- 変数（名前付きメモリ）でできることは、変数を使うべき
- 作品の規模を大きくする時は使うしかない。同じパラメータをもつキャラを複数登場させたい、とか
    <details><summary>例</summary>
    <pre><code>
    # 定数設定
    const ENEMY_MAX -> 30               # 敵の最大機数
    const ENEMY_MEM_SIZE -> 6           # 敵が持つパラメータの個数 ex,ey,edx,edy,etype,ealive
    const BOSS_MAX -> 1                 # ボスの最大機数
    const BOSS_MEM_SIZE -> 8            # ボスが持つパラメータの個数 ・・・・・・・・・・・・・・・・
    # 配列データ格納アドレス
    const e -> 100                      # 敵データ開始アドレス
    const boss -> e + ENEMY_MEM_SIZE * ENEMY_MAX      # ボスデータ開始アドレス
    const item -> boss + BOSS_MEM_SIZE * BOSS_MAX     # アイテムデータ開始アドレス
    ・・・・・・・・・
    # メイン
    while gameover != 1
        ・・・・・・・
        enemy_update()
        ・・・・・・・
    
    # 座標更新
    def enemy_update()
        while *******
            ・・・・・・・
            s -> enemyNo * ENEMY_MEM_SIZE
            e[s + ex] -> e[s + ex] + e[s + edx]
            e[s + ey] -> e[s + ey] + e[s + edy]
            enemyNo -> enemyNo + 1
    </code></pre>
    </details>
- Sunabaの `memory[0] ～ memory[39999]` の管理・運営方法に正解はない。
    - 上級ガイド内のsampleでは、C言語のmalloc() に相当する関数を作って利用している
    - 上手い人の構造は似ているかもしれない。けど、変数の名前のつけ方や、関数の形をどうするか等々、みんな俺様ルールで作っている
    - メモリMAP（番号と役割の対応表）を紙に書いて、コードは `m[....]` の嵐であっても動けばいい
    - Sunaba講座の意義は、論理を組み立てる過程に集中してもらうことにある。`平たく言えば、粘り強く考えてほしいだけある。`成果物の客観的な技術レベルよりも、動くものを作れた時の各々の充実感の方が重要
        <font color="Silver">
        - 後日のC言語講座は、職場で使うことを想定しているので、頭を切り替えてもらう必要がある</font>  
    
#### 特徴５：関数内で計算した結果をひとつだけ、メイン側に返すことができる（戻り値、返り値）
- 今回の課題には不要な機能だが、関数の特徴として最後なるので、ここで伝えておきたい
- 表題の通りだが、関数で計算した結果を関数が書かれている場所に返してくることができる。
    - 「その場所に返ってくる」という動作は `判定式` と同じ
- この機能は、Sunabaでは`出力`という名前がついている。しかし、この講座では次のC言語講座に合わせて `戻り値` と呼ぶ
- 例題を用意する。今後よく使うものがいいと考えて、 **割り算の余り** を計算してくれる関数を作ろうと思う。`剰余`算出関数である
- こんな感じで使うことを想定
    <pre><code>
    # a ÷ b の余りを ans に格納
    a -> 10
    b -> 3
    ans -> modulo(a, b)
    </code></pre>

- 剰余を求める式を作ることはできるだろうか？チェレンジしたい人のために式が隠れるようにしておく
    - ヒント：割り算の結果は小数切り捨てである
    - ansの右辺に直接に式を書けばこんな感じ
        <details><summary>剰余の式</summary>
        <pre><code>
        ans -> a - (b * (a / b))
        </code></pre>
        </details>

- 関数の定義も含めて最終形はこんな感じ
    <details><summary>modulo関数</summary>
    <pre><code>
    # a ÷ b の余りを ans に格納
    a -> 10
    b -> 3
    ans -> modulo(a, b)

    def modulo(de, ds)
        out -> de - (ds * (de / ds))
    </code></pre>
    </details>

    - 戻り値にする値は `out` に入れる。`out` はSunabaシステムで関数用に用意された特別な変数である
    - **`注意`**：自分で定義する変数の名前に `out` は使えない！
    - <font color="Silver">C言語の関数にも戻り値の仕組みがある。しかし違いがあるので注意</font>
        - <font color="Silver">名前は `out` ではなく `return`</font>
        - <font color="Silver">Sunabaの `out` は値を格納しても関数内プログラムが終わるまで何も起きない（終わっていないうちは上書きできる）</font>
        - <font color="Silver">C言語は、`return`文 が書かれた行を実行すると、受け取った値を持って強制的に関数から抜け出す</font>
            - <font color="Silver">職場・業種によっては、関数内プログラムの途中に `return`文 を書いてはいけない、複数`return`を書いてはいけない、というルールが敷かれている可能性がある</font>
            - <font color="Silver">職場・業種のルール上、問題なければ上記の禁止事項に縛られる必要はない</font>

#### 関数の特徴を整理
- 特徴１：実施内容が決まっている処理のパッケージ化
- 特徴２：処理に必要な材料を、呼び出される時に入手できる（引数）
- 特徴３：関数の内側と、外側（メインプログラム側）では、お互い、相手の変数に直接アクセスすることはできない（有効範囲、スコープ）
- 特徴４：関数の内側からでもメモリ番号指示によるメモリへのアクセスは可能
- 特徴５：関数内で計算した結果をひとつだけ、メイン側に返すことができる（戻り値、返り値）

#### ひとこと
- 関数はプログラムを整理する道具なので、どうしても「整理しましょう」というメッセージが強くなってしまった
- しかしSunabaは、初心者が短期間のうちに論理を組み立てることを助ける訓練ツールである
- プログラミング学習が初めてで、もう少し `m[....]嵐コード` を書きたい人は、そのスタイルで行くといい
    - m[....]だらけでも#コメントにメモリの役割を書けば、他人にも多少は伝わる
    - でも、正直に言えばできるだけ早く変数に移行してもらいたい

---
---
## **課題11 横線を描く（関数）**
- `横線を描く関数を作る。入力は5つ：左端点座標x,y 、 長さlen(Lengthのlen) 、色col(Colorのcol) `
- 以前、`横線を描く`を書いたときはこんな形
    <pre><code>
    memory[0] -> 0   # 横線長さカウンタ
    while memory[0] < ＿＿＿＿
        点描画       # 横線長さカウンタで構成した式
        横線長さカウンタのカウントアップ
    </code></pre>

- 関数化は後回しにして、まずは、これを x, y, len, color で表現しよう
    - x, y 初期値は0にしない。狙い通りの位置に描けるか確認するため
    - x, y の値をプログラムの中で変化しないよう注意
        - HINT：横線を描く際のカウンタを別に用意。つまり「いまいくつ点を描いたのか」をカウントする変数を、 変数 x とは別に用意すればいい
    <details><summary>x, y で表現したプログラム</summary>
    <pre><code>
    x -> 15     # 始点座標x
    y -> 10     # 始点座標y
    len -> 20   # 始点からの長さ
    col -> 999900   # 色
    i -> 0   # 描画カウンタ
    while i < ＿＿＿＿
        点描画       # i,x,y,colで構成した式
        描画カウンタのカウントアップ
    </code></pre>
    </details>
- このプログラムを関数としてまとめる前に、`点を描く`箇所を関数にしよう
    - 【新情報】`引数に式を書くことは可能`
    <details><summary>記述例</summary>
    <pre><code>
    x -> 15     # 始点座標x
    y -> 10     # 始点座標y
    len -> 20   # 始点からの長さ
    col -> 999900   # 色

    i -> 0   # 描画カウンタ
    while i < ＿＿＿＿
        point(x + i, y, col)       # i,x,y,colで構成した式
        描画カウンタのカウントアップ
   
    # 関数定義
    def point(x_, y_, color_)
        memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </datails>  
- 横線を関数化しよう。関数名は`lineH`で。（**H**orizontal）
    - 【新情報】`関数の中から関数を呼ぶことは可能`
    <details><summary>記述例</summary>
    <pre><code>
    # 変数定義
    x -> 15     # 始点座標x
    y -> 10     # 始点座標y
    len -> 20   # 始点からの長さ
    col -> 999900   # 色

    # メイン
    lineH(x, y, len, col)

    # 関数定義
    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(**** , **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ
   
    def point(x_, y_, color_)
        memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </datails>  

---
---
## **課題12 縦線を描く（関数）**
- `縦線を描く関数を作る。入力は4つ：上端点座標x,y 、 長さlen(Lengthのlen) 、色col(Colorのcol) `
- 横線は点を横に並べた。縦線は点を縦に並べればいい
- 点の描画はpoint関数を使おう
- 縦線を関数化しよう。課題11の完成コードを複製して作る。lineHは残しておく。縦線描画の関数名は`lineV`としよう（**V**ertical）
    - 【新情報】使わない関数定義を書いていても、エラーにならない
    <details><summary>記述例</summary>
    <pre><code>
    # 変数定義
    x -> 15     # 始点座標x
    y -> 10     # 始点座標y
    len -> 20   # 始点からの長さ
    col -> 999900   # 色

    # メイン
    lineV(x, y, len, col)

    # 関数定義
    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(**** , **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(**** , **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ
   
    def point(x_, y_, color_)
        memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </datails>  

- 不満な要素を洗い出す
    - `y -> 90` に変更して実行してほしい
        - エラーが出ただろうか。画面メモリ外アクセスでエラーになる
    - `y -> 10` に戻した後、もう一つ試してほしいのが横方向。メインに `lineH(90, 10, 30, 990099)` を追記して実行してほしい
        - エラーにはならないが、左端から線が飛び出してくる様子が確認できたと思う
    - これらの挙動についてどう思う？使いにくくない？
- 原因を整理しよう
    - 画面上下エラー：画面メモリ範囲外に点を描こうとして発生するアクセスエラー
    - 画面左右ワープ：画面メモリ番号と画面座標系の違い
        - 左右ワープ現象は順を追って考える。まずは画面メモリ番号と座標系の違いを `式 60000 + (y_ * 100) + x_` で関連付けていることを再認識しよう
            - 画面メモリ番号：画面内をジグザクしながら増加するが、値としては1次元の世界
            - 画面座標系：x,y の2次元。ただし、x,yともに範囲が 0 ～ 99 とする世界
        - 今回の例で細かく確認しよう。`横線の始点x は 90` だが、点を横に描いていく時、`memory[60000 + (y_ * 100) + x_]` の `x_` にどんな値が入力されているか注目してほしい
        - `x_` の変化を追うと、90, 91, 92, ・・・・, 99, `100`, `101`,`・・・`という具合に、100以上を与え続けている
        - 何が問題か分かるだろうか
        - 画面のx座標の範囲は0～99なのに、100 以上の入力を許している
        - 要は、`0～99 ルール` を破るプログラムを書いたのが原因である
        - 0～99 ルールを守りながら作品を作るのは面倒くさそう
-  画面座標系を `上下左右に限りなく伸びる2次元世界` としたい
    - Sunabaの変数は -20億 ～ +20億 を設定できるのだから、x, y座標も -20億 ～ +20億 としたい
    - 0～99 以外の値の時に点を描くプログラムを実行しても、画面に表示されなければいいのである
    - 点描画関数をアップデートすることで実現できる

#### 点描画関数をパワーアップさせる
- 上で挙げた条件で、どうすれば良いか考えられる人は、まずは自分の力で頑張ってみよう
- 追加機能：`x, y座標 が共に 0～99 の範囲内なら画面メモリに書き込む`
- 上記を組み込むにあたって2つの道具を紹介しなければならない
- 【新情報 1】`if 判定式`
    <pre><code>
    if 判定式
        プログラムA
        プログラムB
    プログラムC
    </code></pre>

    - `もし`判定式の結果が
        - `真なら`if文の中のプログラムを実行してから、次のプログラムに移る（判定 → A → B → C）
        - `偽なら`if文の中を実行せず、次のプログラムに移る（判定 → C）
    - `1回しか実行しない while` と思ってもいい

- 【新情報 2】複数の判定結果の判断 `または(or)` と `かつ(and)`
    - 今回の点描画パワーアップには、`xが0～99の範囲内` **`かつ`** `yが0～99の範囲内` という判定式を使う
    - そもそも `xが0～99の範囲内` は判定式としてどうやって書けばよいか？
        - `0 <= x <= 99` と書きたくなるのは自然なことだが、NGである。プログラミング言語全般で認められていない（OKな言語があってもメジャーな書き方ではないはず）
        - ２つに分ける。`0 <= x` と `x <= 99` に分解 
        - `0 <= x` と `x <= 99` の結果がともに真であれば、 `0 <= x <= 99` が成立していると言える
        - つまり `0 <= x ` **`かつ`** ` x <= 99` である。ここで **`かつ`** が必要になるので紹介する
        - C言語には判定式の結果をつなげる `論理演算子` があるが、
            - または(or) ： `||`
            - かつ(and) ： `&&`
            - 等々
        - Sunabaには論理演算子がない
        - 判定式の結果が 1（真）と 0（偽）という整数であることに注目        
        - 普通の算術演算子を使う
            - または(or) ： `+` （足し算）
                - 1 + 1 → 1（真）
                - 1 + 0 → 1（真）
                - 0 + 1 → 1（真）
                - 0 + 0 → 0（偽）
            - かつ(and) ： `*` （掛け算）
                - 1 * 1 → 1（真）
                - 1 * 0 → 0（偽）
                - 0 * 1 → 0（偽）
                - 0 * 0 → 0（偽）
        - くっつければいいけど、`0 <= x * x <= 99` はもちろんNGだ。Sunabaには演算子の優先順位はない
        - xの判定式 ： `(0 <= x) * (x <= 99)` 
        - y も全く同じなので、
        - yの判定式 ： `(0 <= y) * (y <= 99)`
        - 判定式の最終形
            - xの判定式 **`かつ`** yの判定式 
            - `(0 <= x) * (x <= 99) * (0 <= y) * (y <= 99)`
            

- point関数の最終形（lineH, lineV は変更なし）
    <details><summary>記述例</summary>
    <pre><code>
    # 変数定義
    x -> 15     # 始点座標x
    y -> 10     # 始点座標y
    len -> 20   # 始点からの長さ
    col -> 999900   # 色

    # メイン
    lineV(x, y, len, col)

    # 関数定義
    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(**** , **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(**** , **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ
   
    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </details>

- このプログラムで、上下左右の画面枠を超える縦線・横線を描画してみよう


---
---
## **課題13 四角を描く（関数）**
- `四角を描く関数`を作ろう
- 関数名は`rect`、引数は`四角左上頂点座標 x,y`、 `幅 width`、 `高さ height`、 `塗りつぶし色 color`
- 四角はどうやって描いていたか覚えているだろうか
    - 横線を縦に並べて作っていた
- 横線描画関数を使って四角描画関数を作ろう
    - パワーアップ済のpoint関数を使うことで、四角描画としても画面端アクセス違反を気にせず済む
- 最終形
    <details><summary>kadai13</summary>
    <pre><code>
    # 変数定義
    x -> 15     # 左上頂点座標x
    y -> 10     # 左上頂点座標y
    w -> 20     # 幅
    h -> 35     # 高さ
    col -> 999900   # 色

    # メイン
    rect(x, y, w, h, col)

    # 関数定義
    def rect(x_, y_, width_, height, color_)
        ********************
        ***************
        *********
        ****

    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(****, ****, ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(****, ****, ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ
   
    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </details>


---
---
## **課題14** 四角をたくさん描こう
- せっかく四角描画関数を作ったので、画面に`たくさんの四角を描こう。数、大きさ、色は任意`
- まずは各自作成してほしい  
---
#### 乱数（ランダム）
- これまでは適当な値を自分で決めて、引数に数値を直打ちするしかなかったが、もっとスマートに済ませたい
- 他のプログラミング言語には不規則な値を生成してくれる関数が用意されている
- 不規則な値のことを `乱数` または `ランダム` という
- 当たり前だが、Sunabaに乱数生成機能は用意されていないので、作るしかない
- しかし乱数を理解するには、高度な数学知識が必要なので、まともに向き合う気はない
- 上級ガイドの `utility.txt` をカンニングしよう
    <pre><code>
    def random(prev)	# linear congruential generator mod 1048573
        if prev = 0     # 0はマズい
            prev -> 1
        out -> modulo(2043 * prev, 1048573)
    </code></pre>

    - `prev` は `前回データ` を格納する変数によく使う名前（`prev`ious）
    - 乱数を生成する関数（以下、ランダム関数）に `前回データ` を与えるとはどういうことだろうか？
    - 他の言語でよく見かける基本的なランダム関数は、引数に最大値`max`を取り、戻り値として `0` から `max` の範囲内の乱数を返す、という形である
    - 一般的に見かけるランダム関数とは異なるようだ
    - 手掛かりは `linear congruential generator` 
    - ネットで調べれば `線形合同法` が出てくるだろう
    - カンニングコピペしてきたプログラムは、至れり尽くせりな形ではないようだ
    - wikipedia 等の解説を頑張って読んでみてほしい
- 機能検証用のプログラムを示そう
    <pre><code>
    i -> 0
    rnd -> 1
    while i < 99
        rnd -> random(rnd)
        point( modulo(rnd, 99), i, 990099 )
        i -> i + 1

    # 関数定義
    def random(prev)	# linear congruential generator mod 1048573
        if prev = 0     # 0はマズい
            prev -> 1
        out -> modulo(2043 * prev, 1048573)

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_

    def modulo(de, ds)
        out -> de - (ds * (de / ds))
    </code></pre>

    - 生成された乱数を格納する変数 `rnd` の初期値を変えて、不規則性を保ったままどのくらい変化するのか、目視で構わないので確認しよう
        - マイナス値を与える場合は、画面表示側で補正を掛けるなどして確認しよう
- 上で紹介した『 引数に最大値`max`を取り、戻り値として `0` から `max` の範囲内の乱数を返す 』 という関数を作りたい人は各自チャレンジしてほしい。考える時のヒントを記しておく
    - 最大値`max`を使うランダム関数は、実行するたびに異なる値を生成する機能を持つが、今回コピペした関数は定数で構成されているため、与える初期値が同じなら結果も同じになる
    - そこで、実行するたびに異なる値の代表的な存在である `現在時刻` が欲しくなるが、残念ながら Sunabaには現在時刻を取得する機能はない
    - Sunaba で時刻に似たデータを確保するとしたら`画面更新回数`だろうか。ただそれだけでは起動後の経過時間であり、実行タイミングに依存するため規則性が生まれてしまうかも。
    - Sunabaで完璧な姿を追い求める必要はないと割り切って、`まあまあ納得`くらいを目指せばいいんじゃないかな
- そんなわけで、`四角を描く`の最終形は線形合同法をそのまま使う
    <details><summary>kadai14</summary>
    <pre><code>
    rndx_ -> 1
    rndy_ -> 2
    rnd_l -> 3
    rnd_col -> 4
    cnt -> 10

    i -> 0
    while i < cnt
        rndx_ -> random(rndx_)
        rndy_ -> random(rndy_)
        rnd_l -> random(rnd_l)
        rnd_col -> random(rnd_col)
        rect( modulo(rndx_, 99), modulo(rndy_, 90), modulo(rnd_l, 20), modulo(rnd_l, 20), modulo(rnd_col, 999999) )
        i -> i + 1

    # 関数定義
    def random(prev)	# linear congruential generator mod 1048573
        if prev = 0     # 0はマズい
            prev -> 1
        out -> modulo(2043 * prev, 1048573)

    def rect(x_, y_, width_, height, color_)
        ********************
        ***************
        *********
        ****

    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(****, **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < ＿＿＿＿
            point(****, **** , ****)       # i, x_, y_, color_で構成した式
            描画カウンタのカウントアップ

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_

    def modulo(de, ds)
        out -> de - (ds * (de / ds))
    </code></pre>
    </details>

- 完全版（粘り強く考えてから開けよう。その前に見たらスキルアップは保証しない）
    <details><summary>kadai14_1</summary>
    <pre><code>
    # 定数宣言
    const m -> 0

    # 変数宣言
    rndx_ -> 2
    rndy_ -> 1
    rnd_l -> 2
    rnd_col -> 4
    cnt -> 10

    m[55001] ->1	# 手動更新モード

    # メイン
    i -> 0
    while i < cnt
        rndx_ -> random(rndx_)
        rndy_ -> random(rndy_)
        rnd_l -> random(rnd_l)
        rnd_col -> random(rnd_col)
        x -> modulo(rndx_, 99)
        y -> modulo(rndy_, 90)
        l -> modulo(rnd_l, 20)
        col -> modulo(rnd_col, 999999)
        rect( x, y, l, l, col)
        i -> i + 1
    m[55000] -> 1	# 画面更新スイッチON

    # 関数定義
    def random(prev)	# linear congruential generator mod 1048573
        if prev = 0     # 0はマズい
            prev -> 1
        out -> modulo(2043 * prev, 1048573)

    def rect(x_, y_, width_, height_, color_)
        i -> 0   # 描画カウンタ
        while i < height_
            lineH(x_ , y_ + i , width_, color_)       # i, x_, y_, color_で構成した式
            i -> i + 1

    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < length_
            point(x_ , y_ + i , color_)       # i, x_, y_, color_で構成した式
            i -> i + 1

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < length_
            point(x_ + i, y_ , color_)       # i, x_, y_, color_で構成した式
            i -> i + 1

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_

    def modulo(de, ds)
        out -> de - (ds * (de / ds))
    </code></pre>
    </details>

---
---
## **課題15** 画面端で跳ね返る
- `点が上下左右の画面端で反射する` プログラムを作ろう
- 初心者にとっては中規模課題である。一気に完成形にしようとするのではなく、課題を小さく分解し、何から手をつけていくか決めよう
    - 実務では、課題を`十分に分解`してから作業手順を決めなさい、と求められるかもしれない
    - しかし、プログラミング学習を始めたばかりの人に対し、課題を`十分に分解`せよと強要するのは無理がある
        - 学習し始めの段階で課題の分析が苦にならない人は、時間の許す限り課題分析に取り組むといい
    - 課題の抽出が不十分でも、自分なりに見つけた小さな課題解決案を、まずは形にすることが大事。そこから見えることがあるはず
    - 課題解決力の上達には、このルーティンを数多く実行するのが効果的だと考えている
- 一旦、テキストの進行を止めて、自分の力で`点が上下左右の画面端で反射する` プログラムを作ってみてほしい
- いきなり次の作成例を見てしまうと`成長機会を失う`ので注意しよう  

---
### 課題15の作成手順例
1. 点描画関数の活用
    - 点が動くプログラムは以前の課題で作成済だが、その時は点描画関数はなかった。そこから手を着けていこう
    - 点の移動の最終Ver.（kadai7_3 疑似コード）をコピペしてくる
        <pre><code>
        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 1     # x移動量
        dy -> 3     # y移動量
        color -> 990099     # 色

        while y < _____
            前回表示の点を黒で塗りつぶす
            x を +dx
            y を +dy
            memory[60000 + (y * 100) + x] -> color
        </code></pre>

    - これにpoint関数を組み込むと
        <details><summary>kadai15 疑似コード</summary>
        <pre><code>
        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 1     # x移動量
        dy -> 3     # y移動量
        color -> 990099     # 色

        while y < _____
            前回表示の点を黒で塗りつぶす
            xを+dx
            yを+dy
            point(***********)
        
        # 関数定義
        def point(***********)
            ***********
            *******
        </code></pre>
        </details>

    - この時は課題の進行上、ループ回数をy方向の移動距離としていたが、このままでは汎用性に欠ける
    - 今後、メインプログラムは終わりのないループで構成したいと思う
    - 【新情報】無限ループ
        - ゲームに限らず、アプリケーションの多くは、終了処理を実行しない限り終わらないプログラムである
        - そのようなプログラムは、条件が真な限り実行し続けるループの中で、処理を続ける構造になる。このループを `無限ループ` または `メインループ` という。

    - ループは当然 `while` で作ることになる
    - `while` **`常に真`** とすれば無限ループが実現する。**`常に真`** は `0以外の整数` であれば何でもOKだが、普通は `1` である 
    - 変更を加えてみる
        <details><summary>kadai15_1 疑似コード</summary>
        <pre><code>
        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 1     # x移動量
        dy -> 3     # y移動量
        color -> 990099     # 色

        while 1
            前回表示の点を黒で塗りつぶす
            xを+dx
            yを+dy
            point(***********)
        
        # 関数定義
        def point(***********)
            ***********
            *******
        </code></pre>
        </details>

        - 実行すると点が画面外に消えていったと思う。注目してほしいのは、プログラムが動き続けている点である
        - 以前であれば画面外アドレスへのアクセスエラーでプログラム中断となっていた。point関数のパワーアップが効いていることが分かるだろう
        - これにより、あるキャラが一旦画面の外に出て、すぐに画面内に戻ってくる、という当たり前の動作ができるようになる。作品作りに活かしてほしい
    - 次は当たったら跳ね返る、という動作に注目しよう
1. 右端で跳ね返る
    - 画面右端で跳ね返ることだけを考える
    - 移動は水平方向のみとする。初期値を `dx -> 1` ,  `dy -> 0` にしよう
    - 画面右端に到達したら何をすればいいか？
        - 位置更新プログラム『`x` を `+ dx` する』は形を変えずに使うとしよう
        - その場合は `dx` が `-1` になればいいはず。つまり、右端に到達してやることは `dx -> -1` だ
    - 画面右端に到達したことをどうやって判断すればいいか
        - もし `x` が `99` になったら。つまり `if x = 99`
    - プログラムに反映すると
        <details><summary>kadai15_2 疑似コード</summary>
        <pre><code>
        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 1     # x移動量
        dy -> 0     # y移動量
        color -> 990099     # 色

        while 1
            前回表示の点を黒で塗りつぶす
            xを+dx
            yを+dy
            if x = 99
                dx -> -1
            point(***********)
        
        # 関数定義
        def point(***********)
            ***********
            *******
        </code></pre>
        </details>
    - 動くプログラムではあるが、わざと問題を仕込んでいる。その問題を見てもらいたいので、`dx -> 2` で実行してみよう
    - 戻ってこなくなったと思う。問題なのは `if x = 99` であることは明らかだ
        - `if x > 99` に直そう
    - さらに、戻る時が `dx -> -1` のままでは反射時に減速してしまう。
    - 減速を解決するには、`dx -> -dx` とすればいい。これなら `dx` の初期値を変えてもメインプログラムを変える必要はなくなる
1. 左端で跳ね返る
    - 画面左端でも跳ね返るようにしたい
    - 右の時と同じ要領でプログラムを追加すればいいんじゃないだろうか？
    - `x` が `0 未満` になったら `dx` を`反対方向`にすればいい
        <details><summary>kadai15_3 疑似コード</summary>
        <pre><code>

        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 2     # x移動量
        dy -> 0     # y移動量
        color -> 990099     # 色

        while 1
            前回表示の点を黒で塗りつぶす
            xを+dx
            yを+dy
            if x > 99
                dx -> -dx
            if x < 0
                dx -> -dx
            point(***********)
        
        # 関数定義
        def point(***********)
            ***********
            *******
        </code></pre>
        </details>
    - 正しく動くはずだ。どうだろう、いい感じじゃないか？
    - ただ、以下の点、ここ無駄がありそうじゃないか？
        <pre><code>
        if x > 99
            dx -> -dx
        if x < 0
            dx -> -dx
        </code></pre>

    - これは、『 `x > 99` **か** `x < 0` なら `dx -> -dx` 』というプログラムに変更可能である。２つの判定式を一つに連結したい
    - 判定式の結合には、`かつ（and）` と `または（or）` があることは伝えた。ここで使うべきなのは、`または（or）` である
    - Sunabaで `または（or）` を実現するには、各判定式を `+` で連結すればいいことも解説済み。実際に書き換えて動作を確認しよう
    - 最終的に
        <details><summary>kadai15_4 疑似コード</summary>
        <pre><code>
        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 2     # x移動量
        dy -> 0     # y移動量
        color -> 990099     # 色

        while 1
            前回表示の点を黒で塗りつぶす
            xを+dx
            yを+dy
            if (x < 0) + (99 < x)
                dx -> -dx
            point(***********)
        
        # 関数定義
        def point(***********)
            ***********
            *******
        </code></pre>
        </details>

        - 判定式の記述順は『 `x` が `画面外に出たら` 』 という状況をイメージしやすくなるよう工夫した
1. 上下方向の跳ね返り
    - 左右方向がスッキリしたので、上下方向も同じように対応してみよう
    - 画面上下端の判定のプログラムは、x方向のものをコピー＆変更
    - 変数の初期値は縦方向のみの動作とする。 `dx -> 0` ,  `dy -> 2` としよう 
        <details><summary>kadai15_5 疑似コード</summary>
        <pre><code>
        # 点
        x -> 0     # x座標
        y -> 0     # y座標
        dx -> 0     # x移動量
        dy -> 2     # y移動量
        color -> 990099     # 色

        while 1
            前回表示の点を黒で塗りつぶす
            xを+dx
            yを+dy
            if (x < 0) + (99 < x)
                dx -> -dx
            if (y < 0) + (99 < y)
                dy -> -dy
            point(***********)
        
        # 関数定義
        def point(***********)
            ***********
            *******
        </code></pre>
        </details>
    - 問題なく上下端での反射ができたはず
    - 実は、既に斜め方向も反射するプログラムになっている。試しに `x -> 3` にしてみよう。いい感じで跳ね返ってくれるはずだ

    
---
---
## **課題16** 動く点と、動かない四角
- `画面端で反射する動く点：1つ　全く動かない四角：1つ` を描こう
- `四角の位置、大きさ、色` は任意
- 前回の点反射プログラムをコピーして、その中に四角プログラムを追加
- まずは自力で
    <details><summary>kadai16_1 疑似コード</summary>
    <pre><code>
    # 点
    x -> 0     # x座標
    y -> 0     # y座標
    dx -> 0     # x移動量
    dy -> 2     # y移動量
    color -> 990099     # 色

    # 四角
    rcx_ -> 20     # x座標
    rcy_ -> 15     # y座標
    rc_w -> 10     # 幅
    rc_h -> 25     # 高さ
    rccolor_ -> 009999     # 色

    while 1
        # 点
        前回表示の点を黒で塗りつぶす
        xを+dx
        yを+dy
        if (x < 0) + (99 < x)
            dx -> -dx
        if (y < 0) + (99 < y)
            dy -> -dy
        point(***********)

        # 四角
        rect(**************)

    
    # 関数定義
    def ********************
        ***********
        *******

    def ********************
        ***********
        *******

    def point(***********)
        ***********
        *******
    </code></pre>
    </details>

- 完成版（粘り強く考えてから開けよう。その前に見たらスキルアップは保証しない）
    <details><summary>kadai16_2</summary>
    <pre><code>
    # 点
    x -> 0     # x座標
    y -> 0     # y座標
    dx -> 0     # x移動量
    dy -> 2     # y移動量
    color -> 990099     # 色

    # 四角
    rcx_ -> 20     # x座標
    rcy_ -> 15     # y座標
    rc_w -> 10     # 幅
    rc_h -> 25     # 高さ
    rccolor_ -> 009999     # 色

    while 1
        # 点
        point(x, y, 0)
        x -> x + dx
        y -> y + dy
        if (x < 0) + (99 < x)
            dx -> -dx
        if (y < 0) + (99 < y)
            dy -> -dy
        point(x, y, color)
        
        # 四角
        rect(rcx_, rcy_, rc_w, rc_h, rccolor_)


    # 関数定義
    def rect(x_, y_, width_, height_, color_)
        i -> 0   # 描画カウンタ
        while i < height_
            lineH(x_, y_ + i, width_, color_)
            i -> i + 1

    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < length_
            point(x_, y_ + i, color_)
            i -> i + 1

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < length_
            point(x_ + i, y_, color_) 
            i -> i + 1

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </datails>  

- 点の移動速度がかなり遅い。問題はどこにある？
- 四角が動かないという状態は狙い通りだが、この四角、同じ位置・大きさ・色で何回も描いているのである。それ自体は問題ない。
- まずいのは、毎ループ、画面`自動`更新のままドットを描く作業をしていたことである
- `画面手動更新` を使おう
    - 今回のプログラムに `画面手動更新` を入れるにはどうすればいいか
    - 画面手動更新を使い始めた課題08には無限ループがなく、一枚絵を描いて終了するプログラムだった。今回は無限ループに対応させる点が大きな特徴となる
    - 無限ループの中で、画面手動更新ON命令である `memory[55000]->1` を実行する場所は、`無限ループ直下 かつ １箇所`とする
        - 画面更新は、メインループで実行すべきことがおおよそ済んだ後に実施するのが分かりやすい。ループの終盤に `memory[55000] -> 1` を書くのが良いと思う
        - メインループ突入前に、画面更新が必要な場合もある（タイトル画面を付けるなど）
        - 疑似コードで書くと、動きを伴うプログラムのおおまかな構成は以下の通り
            <pre><code>
            変数宣言
            画面手動更新モードに変更
            メインループ
                前回描画の削除（移動を伴う図形に対する処理）
                更新（諸々の計算）
                描画（更新結果の反映）
                画面更新スイッチON
            </code></pre>

- 完成版（粘り強く考えてから開けよう。その前に見たらスキルアップは保証しない）
    - 点の初期値（位置、方向）を変えて動作確認しよう
    <details><summary>kadai16_3</summary>
    <pre><code>
    # 点
    x -> 0     # x座標
    y -> 0     # y座標
    dx -> 0     # x移動量
    dy -> 2     # y移動量
    color -> 990099     # 色

    # 四角
    rcx_ -> 20     # x座標
    rcy_ -> 15     # y座標
    rc_w -> 10     # 幅
    rc_h -> 25     # 高さ
    rccolor_ -> 009999     # 色

    memory[55001] -> 1  # 画面手動更新モードに変更

    # メイン
    while 1
        # 前回描画の削除
        point(x, y, 0)

        # 点の更新
        x -> x + dx
        y -> y + dy
        if (x < 0) + (99 < x)
            dx -> -dx
        if (y < 0) + (99 < y)
            dy -> -dy

        # 描画
        point(x, y, color)
        rect(rcx_, rcy_, rc_w, rc_h, rccolor_)

        memory[55000] -> 1  # 画面更新スイッチON


    # 関数定義
    def rect(x_, y_, width_, height_, color_)
        i -> 0   # 描画カウンタ
        while i < height_
            lineH(x_, y_ + i, width_, color_)
            i -> i + 1

    def lineV(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < length_
            point(x_, y_ + i, color_)
            i -> i + 1

    def lineH(x_, y_, length_, color_)
        i -> 0   # 描画カウンタ
        while i < length_
            point(x_ + i, y_, color_)
            i -> i + 1

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </datails>  

---
---
## **課題17**  動く点と、動く四角
- `画面端で反射する　点：1つ　四角：1つ` を描こう
- 前回のプログラムをコピーして、四角に動きを加えよう。点のプログラムを真似ればいい
- まずは自力で！
    <details><summary>kadai17 改善前</summary>
    <pre><code>
    # 点
    x -> 0  # x座標
    y -> 0  # y座標
    dx -> 1  # x移動量
    dy -> 2  # y移動量
    color -> 990099  # 色

    # 四角
    rcx_ -> 20  # x座標
    rcy_ -> 15  # y座標
    rc_dx -> 2  # x移動量
    rc_dy -> 1  # y移動量
    rc_w -> 10  # 幅
    rc_h -> 25  # 高さ
    rccolor_ -> 009999  # 色

    memory[55001] -> 1  # 画面手動更新モードに変更

    # メイン
    while 1
        # 前回描画の削除
        point(x, y, 0)
        rect(rcx_, rcy_, rc_w, rc_h, 0)

        # 点の更新
        x -> x + dx
        y -> y + dy
        if (x < 0) + (99 < x)
            dx -> -dx
        if (y < 0) + (99 < y)
            dy -> -dy

        # 四角の更新
        rcx_ -> rcx_ + rc_dx
        rcy_ -> rcy_ + rc_dy
        if (rcx_ < 0) + (99 < rcx_)
            rc_dx -> -rc_dx
        if (rcy_ < 0) + (99 < rcy_)
            rc_dy -> -rc_dy

        # 描画
        point(x, y, color)
        rect(rcx_, rcy_, rc_w, rc_h, rccolor_)

        memory[55000] -> 1  # 画面更新スイッチON

    # 関数定義
    def rect(x_, y_, width_, height_, color_)
        i -> 0# 描画カウンタ
        while i < height_
            lineH(x_, y_ + i, width_, color_)
            i -> i + 1

    def lineV(x_, y_, length_, color_)
        i -> 0# 描画カウンタ
        while i < length_
            point(x_, y_ + i, color_) # i, x_, y_, color_で構成した式
            i -> i + 1

    def lineH(x_, y_, length_, color_)
        i -> 0# 描画カウンタ
        while i < length_
            point(x_ + i, y_, color_) # i, x_, y_, color_で構成した式
            i -> i + 1

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_
    </code></pre>
    </details>

    - ちゃんと動く。しかし、気になるのは `『# 前回描画の削除』`の部分。今は動く物体が２つしかないが、これが増えていくと以下のような状態になる
        <pre><code>
        # 前回描画の削除
        point(x, y, 0)
        rect(rcx_, rcy_, rc_w, rc_h, 0)
        point(x2, y2, 0)
        point(x3, y3, 0)
        point(x4, y4, 0)
        point(x5, y5, 0)
        ・・・・・・・
        ・・・・・
        ・・・
        </code></pre>

    - 煩雑でしょう？
    - 画面すべてを真っ黒に塗る機能を用意すれば、新しい物体（以下、オブジェクト）を追加するたびに、`『# 前回描画の削除』`にプログラムを追加する必要がなくなる  

#### 画面更新時の全画面クリア
- 画面すべてを真っ黒に塗る機能を`全画面クリア`と呼ぶ
- 関数名：`clear`　引数：なし
- 自力で作るとなると、まず思い浮かぶのはこれが多いと思う
    <pre><code>
    def clear()
        rect(0, 0, 99, 99, 0)
    </code></pre>

- これで何も問題はないのだが、rectの中身はそこそこ頑張っているプログラムである（二重ループ）
- 全画面を黒くするだけならrectの中のプログラムよりも簡素化できる（＊＊＊＊部は考えてみてほしい）
    <pre><code>
    def clear()
        i -> 0
        while i < *****
            memory[****************] -> 0
            i -> i + 1
    </code></pre>

- これまでの知識を整理すると、`Sunabaプログラムの基本構成`は以下のようになる

    ```
    # 定数宣言
    ・・・・
    ・・・

    # 変数宣言
    ・・・・
    ・・・

    memory[55001] -> 1      # 画面手動更新モード

    # メイン
    while 1
        clear()             # 前回画面情報クリア
        # 更新
        ・・・・・・・
        ・・・・・
        # 描画
        ・・・・・・・
        ・・・・・
        memory[55000] -> 1  # 画面更新スイッチON

    # 関数定義
    ・・・・・・・
    ・・・・・
    ・・・
    ・・
    ```


---
---
## **課題18** 矢印キーで点を動かす
- キー操作が出来なければ作品の幅はかなり狭まる。作品をインタラクティブにするには入力を検知できなければならない
- 【新機能】 キーボードの入力データを活用
- 矢印キーの入力情報が反映されるメモリ番号を、Sunaba早見表で確認しよう
- この領域はメモリの値を読むことはできるが、書き込めない。画面メモリとは逆の挙動である
- Sunabaの外側の情報を反映して勝手に回るダイヤル。手で回せない、数字を読むことだけできる、というイメージ
- ここで作るプログラムは、`右矢印キーを押したら右に行く。 左矢印ボタンを押したら左に行く。上下も。それだけ。`としよう
- point関数を使えば、画面外に出てもエラーにならないし、画面内に戻ってくることもできる
- 自力でできるところまで頑張ってみよう
    <details><summary>kadai18 擬似コード</summary>
    <pre><code>
    # 点
    x -> 0     # x座標
    y -> 0     # y座標
    sp -> 2    # 速度
    color -> 990099     # 色

    memory[55001] -> 1  # 画面手動更新モードに変更

    # メイン
    while 1
        clear()     # 前回画面情報クリア

        # 点の更新
        if memory[*****] = 1      # 右
            x -> x + sp
        if memory[*****] = 1      # 左
            x -> x - sp
        if memory[*****] = 1      # 上
            y -> y - sp
        if memory[*****] = 1      # 下
            y -> y + sp
        
        # 描画
        point(x, y, color)
        
        memory[55000] -> 1  # 画面更新スイッチON


    # 関数定義
    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_

    def clear()
        i -> 0
        while i < 10000
            memory[60000 + i] -> 0
            i -> i + 1

    </code></pre>
    </details>

---
---
## **課題19** お絵かきソフトを作る
- `真っ黒なキャンバス上にマウスのポインタを置き、左クリックすると点を描く。色は任意`
- 【新機能】 マウスの入力データを活用
- キーボードと同じ話なので、早見表を見れば良い
- 無限ループで常にマウスの状態を確認して、画面メモリに点を書き込む、という構成になる
- 今回のプログラムは画面更新がないので、Sunabaの基本構成を使わない。関数もpoint関数だけコピーしてくれば事足りるでしょう
- 完成形（粘り強く考えてから開けよう。その前に見たらスキルアップは保証しない）
    <details><summary>kadai19</summary>
    <pre><code>
    x -> 0
    y -> 0
    while 1
        x -> memory[50000]
        y -> memory[50001]
        if memory[50002] = 1
            point(x, y, 990099)

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_

    </code></pre>
    </details>

---
---
## **課題20** お絵かきソフトを進化させる
- `何かしら機能を付け足して、パワーアップ`
    - 右クリックを押すと黒で描画（消しゴム）
    - キー入力で色を選択できるようにする
        - 現在選択している色をどこかに表示しておく、とか
    - 四角を描く機能を付け足す
    - 【上級者向け】ポインタの動きが速くてもラインを途切れないようにする（ブレゼンハムのアルゴリズム）

---
---
## **課題21** キー操作のオブジェクトと勝手に動くオブジェクト
- `キー操作で動く点と、勝手に動く四角が、共存している状態にする`
- 課題17をベースに書き換えるのが楽だと思う
- まずは自力で
- 完成形（粘り強く考えてから開けよう。その前に見たらスキルアップは保証しない）
    <details><summary>kadai21</summary>
    <pre><code>
    # 点
    x -> 0  # x座標
    y -> 0  # y座標
    sp -> 2  # 速度
    color -> 990099  # 色

    # 四角
    rcx_ -> 20  # x座標
    rcy_ -> 15  # y座標
    rc_dx -> 2  # x移動量
    rc_dy -> 1  # y移動量
    rc_w -> 10  # 幅
    rc_h -> 25  # 高さ
    rccolor_ -> 009999  # 色

    memory[55001] -> 1  # 画面手動更新モードに変更

    # メイン
    while 1
        clear() # 前回画面情報クリア

        # 点の更新
        if memory[50004] = 1  # 上
            y -> y - sp
        if memory[50005] = 1  # 下
            y -> y + sp
        if memory[50006] = 1  # 左
            x -> x - sp
        if memory[50007] = 1  # 右
            x -> x + sp

        # 四角の更新
        rcx_ -> rcx_ + rc_dx
        rcy_ -> rcy_ + rc_dy
        if (rcx_ < 0) + (99 < rcx_)
            rc_dx -> -rc_dx
        if (rcy_ < 0) + (99 < rcy_)
            rc_dy -> -rc_dy


        # 描画
        point(x, y, color)
        rect(rcx_, rcy_, rc_w, rc_h, rccolor_)

        memory[55000] -> 1  # 画面更新スイッチON


    # 関数定義
    def rect(x_, y_, width_, height_, color_)
        i -> 0# 描画カウンタ
        while i < height_
            lineH(x_, y_ + i, width_, color_)
            i -> i + 1

    def lineV(x_, y_, length_, color_)
        i -> 0# 描画カウンタ
        while i < length_
            point(x_, y_ + i, color_) # i, x_, y_, color_で構成した式
            i -> i + 1

    def lineH(x_, y_, length_, color_)
        i -> 0# 描画カウンタ
        while i < length_
            point(x_ + i, y_, color_) # i, x_, y_, color_で構成した式
            i -> i + 1

    def point(x_, y_, color_)
        if (0 <= x_) * (x_ <= 99) * (0 <= y_) * (y_ <= 99)
            memory[60000 + (y_ * 100) + x_] -> color_
            
    def clear()
        i -> 0
        while i < 10000
            memory[60000 + i] -> 0
            i -> i + 1

    </code></pre>
    </details>


---
---
## **課題22** ブロック崩しの自機と弾
- ここからは、ステップバイステップで一つの作品を仕上げたい。題材は`ブロック崩し`
- 自機は、左右移動のみ出来る横長（5ドット）の棒
- 弾は１ドットの点
- 自機の２ドット上に弾が止まっている状態からスタート
- 発射前の弾が自機に追従する
- ここまで作ってみよう


---
---
## **課題23** 弾を発射
- スペースキーを押したら、斜め方向に弾が飛んでいく。弾が飛んだあとも、自機（棒）はキー操作できる
- 弾の移動量は x方向：1、y方向：1 にしておこう（弾の速さの変更は課題26とする）
- 弾は壁で跳ね返る。自機に当たっても跳ね返る

    <details><summary>解決法が思い浮かばない時の検索ワード</summary>
    <pre><code>
    プログラミング フラグ flag
    </code></pre>
    </details>


---
---
## **課題24** ブロックを追加
- 大きめのブロックを１つ追加する
- 画面真ん中より少し上のほう
- 弾はこの壁に当たると跳ね返る
- ブロックは弾に５回当てられると消える
- これで基本形は終了
- まだ余力のある人は、次の課題以降にもチャレンジ
- ブロック崩しはもう嫌だ、という人は課題27にジャンプ

---
---
## **課題25** タイムゲージ
- 画面上部にタイムゲージを設置
- 赤ラインがどんどん短くなっていく。元々赤かった箇所は灰色
- 残り１/４で点滅
- ゲージが減っていくスピード、点滅周期、ともに1/60秒では速すぎる
- プログラムのループの更新速度は1/60秒固定だと考えよう
- ゆっくりした時間を作るにはどうすればいい？

---
---
## **課題26** ゲーム性を持たせる
- ゲームクリア：ブロックを破壊
- ゲームオーバー：弾が下に落ちる、時間切れ
- ゲームクリア、ゲームオーバーの表示
- 弾の進む速さ、角度を変える
- 弾の大きさ変更
- ブロック数増加
- アイテム出現、などなど
- 改造する前に、課題25のプログラムを俯瞰してみよう。全体の構成を把握できるだろうか
- 「動くけどこれ以上の追加は無理」「バグだらけで何がなんだかわからない」という人向けのテクニックを紹介する
- 【新機能】`定数`
    -  文字列と数値を紐付ける機能である
    <pre><code>
    const UP -> 0
    const DOWN -> 1
    dirc -> UP
    if (dirc = DOWN)
    ・・・・・・・・
    ・・・・・
    ・・・
    </code></pre>
 
    - 名前付きメモリ（変数）と異なるのは、
        - タブ無しの階層（一番左）でしか宣言できない
        - 一度宣言したら値変更できない
        - スコープは関係ない（関数の中でも使える）
    - Sunabaのconst宣言した定数には、もう一つの機能がある
- 【新機能】`memory` の代わりに`定数でメモリに名前を付ける`
    <pre><code>
    # constを使ったサンプル
    const BW -> 10   # ブロックの横幅
    const bX -> 100   # ブロックのx座標アドレス
    bNum -> 0   # ブロックの番号
    bX[bNum] -> 10 + (bNum * (BW + 2))
    ・・・・・・・・
    ・・・・・
    ・・・
    </code></pre>

    - BWはすでに解説済の一般的な定数の使い方 (初期値を変えたくないだけ、という理由で使用)
    - bXがC言語の配列的な使い方（こちらが新機能）
        - 定数（ここではbx）を配列の先頭アドレスとする手法。`const bx -> 100` としたときの、`bx[...]`と`memory[...]`の表記を比べるとこんな感じである
            - `bx[0] -> 10` は、`memory[100] -> 10` のこと
            - `bx[1] -> 10` は、`memory[100 + 1] -> 10` つまり、`memory[101] -> 10`のこと
            - `bx[10] -> 10` は、`memory[100 + 10] -> 10` つまり、`memory[110] -> 10`のこと
            - ・・・・・
            - ・・・ 
        - 他の言語のような便利機能はないが、工夫次第で、ちゃんと配列として使うことができる
    - 実はすでに大きな配列データを頻繁に使っていた。画面メモリである。以下のように使うとプログラムが読みやすくなる
        <pre><code>
        const SCREEN -> 60000
        SCREEN[(100 * y) + x] -> 990099
        </code></pre>

- ブロックを複数作ろうとしたら、配列データを扱えるようにしたいはず。チャレンジャーはがんばってみよう
- ちなみに、配列データを作ると、Sunaba的にはメモリ直アクセスなので、関数内から直接アクセスできるのだ。
- ブロック崩しのブロックの処理をゴソッと関数化できる。 updateBlocks 、drawBlocksとかいう名前を付けてまとめてみよう。メインループをシンプルに書くことができるぞ
- 配列にする必要がないオブジェクトの変数も、関数内から直接アクセスしたい場合はどうすればいいのだ？（barとかballの制御もパッケージ化したい！）
    - 要素数1個の配列データ、ってことにすればいいんじゃないか？
- オブジェクトと変数の関係を整理できていないうちに使うと、難読不能なスパゲッティプログラムになるので注意
    - `変数名で役割を明確にしよう`。どのオブジェクトの、何を意味する変数なのかを変数名で表現する
    - `そんなことすぐできるか！`という声は正しい。変数や関数の名前付けは難しい。これは自分で工夫を重ねたり、職場・書籍・ネットで閲覧できるプログラムを見て少しずつ力を付けていくものだと思う。`命名則`というキーワードで資料を漁ってみるのもいい。
- この課題で紹介した機能は、Sunabaの文法ルールを活用したテクニックなので汎用性はないが、もう少しの間Sunaba作品を作りたいという場合は活用してほしい

---
### `column` Sunaba後のC言語学習の流れ
- 上述の手法を要約すると `オブジェクトが持つ変数（例えば自機の座標x,y）をグローバル変数にし、関数内から直接読みに行けるようにすることで大きなプログラムを整理する方法` となる
    - `グローバル変数` はどこからでもアクセスできる変数。詳しくはWeb検索で調べてみよう
- 大前提として、この方法を実際の仕事で使ってはいけない。間違いなく怒られる。そのことを理解してもらったうえで話を進める
- これからSunaba後のC言語学習の流れを示すのだが、まずはSunabaよりも不便な環境が過去にあったことを話したい
- かなり前に普及していた `BASIC` という言語にはスコープがなかった。つまり前述の手法はSunaba特有の話ではないことになる
    - 今のBASICにはスコープがある
- しかも、BASICには変数名に大文字・小文字の区別がつかないので、整理のしやすさについてはSunabaよりも厳しい（BASICは大文字だけで書くのが普通）
- そのBASICで複雑なPCゲームを作っていた時の厄介さに比べれば、Sunabaで冒頭の手法を使って作品を作ることは、かわいいものかもしれない。しかし、それは昔との比較であって、まあまあ無茶な作業であることには変わりない
- で、その無茶っぽいことをして得た実力はどうなるのだろうか？ そこは、将来に活きるので安心してほしい
- 今時の言語には必ず備わっている`クラス`という機能を扱えば、オブジェクトの変数・関数をひとまとめにでき、スコープも切られる
- 例えば、自機を定義するJikiクラスを作る時はこんな感じ
    <pre><code>
    // Jikiの擬似コード
    class Jiki{
        float x, y;
        float dx, dy;
        ・・・・・・・
        ・・・・
        ・・
        void move(){
            x = x + dx;
            y = y + dy;
        }
    }
    </code></pre>

- 自機クラスのx,y座標は、自機クラスがもつmove関数から、グローバル変数にアクセスする様に書くことが可能（引数で受け取る必要はない）。それでいて、他のオブジェクトから読み書きされる危険を排除する仕組みなのである
- C言語にはクラスがないがオブジェクトの独立性を高める書き方は可能である。それには `ファイル分割` を使うことになる
- `C言語のファイル分割` は、`オブジェクトごとに世界を区切る` ために実施するものである。長くなったプログラムを分割するのが主な理由ではない
    - だから、あるファイルのプログラムだけ異様に短い、なんて別におかしくないのである
- この`C言語のファイル分割` の意義を知るためには、C言語を学んでいる最中に他のプログラミング言語でクラスの初歩を学習するべきだと考えている
- C言語のファイル分割ははっきり言って直観的でない。`オブジェクトの変数・関数は独立しているといい` という感覚的に理解できることを、直観的に使えない道具 `ファイル分割` で実現しなければならない
- だからC言語のみで `オブジェクトの変数や関数を独立させる考え方` を理解しようとするよりも、他のプログラミング言語のチカラを借りたほうが良いと考えるのである
- 私はその役割として `Proessing` が一番だと思う。理由は以下の通り
    - 文法がC言語に近いので学習時間が短くできる。それから、いわゆる `おまじない` が排除されているので、`「これどういう意味？」`を意識せずに済む
    - 実行結果を動きのある絵で示せる
    - トライ＆エラーが容易（開発環境のエディタに直接プログラムを書いて実行ボタンを押すだけ）
- C言語学習の前にProcessingを利用しないのは、
    - `便利な道具に慣れ親しんだ後に、わざわざ不便なものに時間を割きたくなるか？` という懸念（例外的な人がいるのはわかるが、多くの人に当てはまることを考えたい）
    - C言語と同様、インデントを付けなくても動作には影響しないので、Processing初心者はインデントが崩れたままゴチャゴチャ書いてしまう、というケースをよく見る。学習時間が豊富であれば目くじら立てることではないが、C言語習得の時間が限られている場合、この回り道は痛い
- C言語学習前にSunabaを利用するのは、
    - 黒い画面とのやり取りに面白さを見いだせない人に、違う面白さを提供できる
        - C言語であってもDXライブラリであれば参考資料が多いので学習はしやすいが、実行までの待ち時間が長い
    - 文法学習を最小化することで作品作りに意識を持っていきやすい。早いうちにプロジェクトベースの訓練に移行できる
        - C言語は文法ルールが少ない言語だけど、初心者にとっては規模がでかい
    - インデントをつける習慣を持っている状態でスタートを切れる
        - C言語へ移行したばかりの時は中括弧 `{...}` が煩わしく思えるかもしれない
    - 文字の入出力とファイルアクセスできることが嬉しいと思える。便利かつ世界が広がった印象を受ける。
        - もしかしたら黒い画面で文字だけのやり取りをするプログラムに面白みを感じられるかも
- ちなみにC言語の文字制御とファイル制御は他の言語に比べて面倒くさい。C言語だけで使いこなす域をいきなり目指すより、ここは他言語の楽さ加減を知っておいていいかもしれない。ここでもProessingを使えばいい


---
---
## **課題27** なにか作る
- Sunabaは十分満喫した、もしくはC言語で作りたいものがある、という場合は技術研修報告書を書いてC言語に進もう！
- Sunabaで一から作品を作る経験を得たい場合は、時間が許す範囲でチャレンジしてみよう
- Sunabaはやろうと思えば結構できることは多いが、文字を主体とした作品はやめたほうがいい
- いくつか案を出してみよう
- 連打ゲーム
    - ボタンを押すと画面上の絵に何かしら変化を起こせばいい。タイマーを付け足すだけでゲームになる。配列とか難しいことを考えなくていいので、おすすめ
- pong 
    - 棒をラケットに見立てて、ボールを打ち合う、アレだ
    - ブロック崩しよりロジックが簡単
    - 敵AIを作ってみるのにちょうどいい題材かもしれない
- 豆拾いゲーム
    - 点をRandomでちりばめるプログラムを応用できる
    - タイムバーを設けるだけでちゃんとゲームになる
    - サンプルコードのドット絵の描き方は、仕組みが分かりやすいと思う
- シューティング
- スゴロク
- ライフゲーム
    - 挑戦する場合はせっかくなので、お手本コードを見ず、仕様からコードに落とし込む作業を自力でチャレンジしてほしい（仕様はWikipediaの説明文）
- テトリス、ぷよぷよ